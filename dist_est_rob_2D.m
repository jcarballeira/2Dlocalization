function [laser_scan]=dist_est_rob_2D(position,map,mapmax,mapmin,err_dis,NUM_MEASUREMENTS,SENSOR_RES,SENSOR_RANGE,T)
%--------------------------------------------------------------------------
%   Function: dist_est_2D
%   Author: Fernando Martin Monar, Luis Moreno
%   Date: November, 2015
%--------------------------------------------------------------------------
% -> Description: a 2D laser scan is estimated for a given position in a
% known map.
%    Similar to dist_est_2D, but this option allows the introduction of
%    uniform noise in the real scan obtained from the robot. Therefore,
%    this function will be call only to measure from the real position. The
%    contamination level is given by the variable CONTAMINATION_LEVEL,
%    which is explained at the end of the script. 
%--------------------------------------------------------------------------
% -> Inputs:
%       -position: Pose from which the measurements are estimated. Vector
%       coordinates are given in Cartesian coordinates and orientation (3
%       dof).
%       -map: 2D Map of the environment. Known map to estimate readings. In
%       map, 0 is an obstacle, 1 represents free space and 0.5 is unknown.
%       -mapmax: Vector of 3 elements that corresponds to the map size. The
%       first two coordinates are the map dimensions, in Cartesian
%       coordinates, and the third one is the orientation, typically 360
%       degrees.
%       -mapmin: Minimum index in the map. Typically =[1,1,0].
%       -err_dis: Sensor noise, standard deviation, in percentage over the
%       distance weighted.
%       -NUM_MEASUREMENTS: Number of horizontal measurements in a scan.
%       -SENSOR_RES: Laser sensor angular resolution (radians).
%       -T: Translation constant. To estimate laser beams in order to
%       generate a laser scan, this function considers increments of T
%       units in the map.
%--------------------------------------------------------------------------
% -> Outputs: 
%       -laser_scan: Vector with NUM_MEASUREMENTS elements containing the
%       distances of the laser measurements.
%--------------------------------------------------------------------------
% -> File requirements: this function is called by Global_Local_2D.m
%--------------------------------------------------------------------------
% -> See also: Global_Local_2D
%--------------------------------------------------------------------------
laser_scan=zeros(1,NUM_MEASUREMENTS);
ths=+90*pi/180; % Angle of the first measurement.

for j=1:NUM_MEASUREMENTS
    
    x=position(1);
    y=position(2);
    thr=(-position(3)+90)*pi/180;   % from deg to radians   
    
    sin_sensor=sin(thr+ths);
    cos_sensor=cos(thr+ths);
    incr_x=T*sin_sensor;
    incr_y=T*cos_sensor;
    
    final=0;
    dis=0;

    while(final < 2)
        
        x_round=round(x);
        y_round=round(y);

        if map(x_round,y_round)==0
            if dis==0,
              dis=sqrt((x-position(1))^2+(y-position(2))^2);
              final=final+1;
            end           
        end    

        x=x+incr_x;
        y=y+incr_y;  
         
        if x>mapmax(1), final=2;end
        if x<mapmin(1), final=2;end
        if y>mapmax(2), final=2;end
        if y<mapmin(2), final=2;end    
    end
    
    if dis<0,dis=0;end
    if dis>SENSOR_RANGE, dis=SENSOR_RANGE;end

    laser_scan(j)=dis;
    ths=ths-SENSOR_RES; % Change of orientation between measurements.
end 

% Normally distributed noise is added to the measurements. 
err_m=randn(size(laser_scan));    % A N(0,1) distribution is generated.
err_level=laser_scan.*err_dis;    % The standard deviation is computed for 
%                                   each measurement.
laser_scan=laser_scan+(err_m.*err_level);   % The final measurement 
%                   contains noise with a standard devation proportional to
%                   the distance weighted.

% Uniform contamination can be included for testing.
CONTAMINATION_LEVEL=0.00; % Percentage of measurements that will be generated by uniform noise (over 1)
CORRECT_MEASUREMENTS=1-CONTAMINATION_LEVEL;  % Number of measurements that corresponde to true lectures (without uniform noise)
err_m2=(rand(size(laser_scan)).*0.5)+0.25;   % Uniform distribution in the interval [0.25,0.75];  
err_cont=laser_scan.*err_m2;      % Equivalent contaminated measurement for each reading. 
% The new scan will be formed by a combination of laser_scan and err_contr.
% err_m3 and err_m4 weight the new scan:
%      err_m3 is 1 for the index of the correct readings and 0 otherwise.
%      err_m4 is 1 for the index of the wrong readings and 0 otherwise.
% They are complementary weights that add to 1.
err_m3=rand(size(laser_scan));    % Uniform(0,1) distribution
err_m3=(err_m3<=CORRECT_MEASUREMENTS);  % if TRUE, err_m3(i)=1 
                                       % if FALSE, err_me(i)=0
err_m4=ones(size(laser_scan))-err_m3;
laser_scan=err_m3.*laser_scan+err_m4.*err_cont; % The new scan is formed

end