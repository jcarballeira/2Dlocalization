function[bestmem,error,population,F,NP]=alg_genet_2D(version_de,version_fitness,laser_real,map,population,iter_max,mapmax,mapmin,err_dis,NUM_MEASUREMENTS,SENSOR_RES,NP,D,F,CR,SENSOR_RANGE,T)
%--------------------------------------------------------------------------
%   Function: alg_genet_2D
%   Author: Fernando Martin Monar.
%   Date: November, 2015
%--------------------------------------------------------------------------
% -> Description: DE-based filter that is executed to obtain the robot's
% location in a known map. The laser scan and the known map are used to
% estimate the robot's pose. The core engine is the DE algorithm and the
% cost value is generated by fitness_3d.m.
%--------------------------------------------------------------------------
% -> Inputs:
%       -version_de: Type of DE version, chosen via keyboard.
%       -version_fitness: Type of fitness function, chosen via keyboard.
%       -laser_real: Vector with NUM_MEASUREMENTS elements containing the
%       distances of the laser measurements from the true location.
%       -map: 2D Map of the environment. Known map to estimate readings.
%       -population: population set. Matrix with dimensions NP*(D+1) where
%       each row contains a candidate with an associated cost value (first
%       column).
%       -iter_max: Maximum number of iterations.
%       -mapmax: Vector of 3 elements that corresponds to the map size. The
%       first two coordinates are the map dimensions, in Cartesian
%       coordinates, and the third one is the orientation, typically 360
%       degrees.
%       -mapmin: Minimum index in the map. Typically =[1,1,0].
%       -err_dis: Sensor noise, standard deviation, in percentage over the
%       distance weighted.
%       -NUM_MEASUREMENTS: Number of horizontal measurements in a scan.
%       -SENSOR_RES: Laser sensor angular resolution (radians).
%       -NP: Population size.
%       -D: Number of chromosomes (DE parameter).
%       -F: Differential variations factor. Mutation coefficient (DE).
%       -CR: Crossover constant (DE).
%       -SENSOR_RANGE: Laser sensor range
%       -T: Translation constant. To estimate laser beams in order to
%       generate a laser scan, dist_est_2D considers increments of T units
%       in the map.
% -> Outputs:
%       -bestmem: Vector of D+1 elements containing the solution of the
%       global localization filter (robot's location) and its cost value in
%       the first element.
%       -error: Cost value of the best candidate.
%       -population: Population set after convergence or maximum iter.
%       -F: mutation factor (it is varied in some options).
%       -NP: population size after convergence (it is varied in some
%       options).
%--------------------------------------------------------------------------
% -> See also: Global_Local_2D dist_est_2D fitness_2D
%--------------------------------------------------------------------------   

%Initilization of variables
trial=zeros(1,D);
bestmem=zeros(1,D+1);
pob_aux=zeros(NP,D+1);
count_a=0; % Counters to check convergence
count_b=0;
count_c=0;
count=1;
imp_count=1;
error_max=100000;
error=10000;
dif_errores=100000;
%--------------------------------------------------------------------------   

%The cost value is computed for the initial population
for i=1:NP
    prev=[population(i,2),population(i,3),population(i,4)];
    laser_estimate=dist_est_2D(prev,map,mapmax,mapmin,err_dis,NUM_MEASUREMENTS,SENSOR_RES,SENSOR_RANGE,T);
    if (version_fitness==7)
        population(i,1)=fitness_2D(laser_real,laser_estimate,version_fitness,NUM_MEASUREMENTS,population(i,5));
    else
        population(i,1)=fitness_2D(laser_real,laser_estimate,version_fitness,NUM_MEASUREMENTS);
    end
end
%--------------------------------------------------------------------------
while (count<=iter_max)%&&(error~=error_max)%&&(error_max>error+10)%3*NP/2) %&&(error>NS/3))%%&&(count_c<30)&&((count_a<100)||(count_b<100)))
     %( (count<=iter_max)&&(error>150)&&(count_c<30)&&((count_a<100)||(count_b<100)))
    for i=1:NP

        % Three random vectors are selected for mutation.
        a=random('unid',NP);
        while((a==i)||(a==0))
            a=random('unid',NP);
        end
        b=random('unid',NP);
        while((b==i)||(b==a)||(b==0))
            b=random('unid',NP);
        end
        c=random('unid',NP);
        while((c==i)||(c==a)||(c==b)||(c==0))
            c=random('unid',NP);
        end
        
        % Mutation and crossover. Different mutation options
        for k=2:(D+1)
            cross_rand=random('unid',100);
            if(cross_rand < (100*CR))
                if (version_de==3)
                    if population(a,1)<population(b,1)
                        if population(a,1)<population(c,1)
                            trial(1,(k-1))=population(a,k)+ F*(population(b,k)-population(c,k));
                        else
                            trial(1,(k-1))=population(c,k)+ F*(population(a,k)-population(b,k));
                        end
                    else if population(b,1)<population(c,1)
                            trial(1,(k-1))=population(b,k)+ F*(population(c,k)-population(a,k));
                        else
                            trial(1,(k-1))=population(c,k)+ F*(population(a,k)-population(b,k));
                        end
                    end
                else
                    trial(1,(k-1))=population(c,k)+ F*(population(a,k)-population(b,k));
                end
            else trial(1,(k-1))=population(i,k);
            end
            % We check that we are still in the map limits.
            if (trial(1,(k-1))<mapmin(k-1))
                trial(1,(k-1))=mapmin(k-1);
            end
            if (trial(1,(k-1))>mapmax(k-1))
                trial(1,(k-1))=mapmax(k-1);
            end
        end

        % Selection
        % The cost value is computed for the trial vector.
        laser_est_from_trial=dist_est_2D(trial(1:3),map,mapmax,mapmin,err_dis,NUM_MEASUREMENTS,SENSOR_RES,SENSOR_RANGE,T);
        if (version_fitness==7)
            error_trial=fitness_2D(laser_real,laser_est_from_trial,version_fitness,NUM_MEASUREMENTS,trial(4));
        else
            error_trial=fitness_2D(laser_real,laser_est_from_trial,version_fitness,NUM_MEASUREMENTS);
        end
        
        % If the error of the trial vector is better, the current
        % population member will be replaced by the trial vector.
        % Threshodlding and Discarding are tools to avoid optimization in
        % the noise band.
        if version_de==2 % Without Thresholding
            if(error_trial<population(i,1)) 
                for j=2:(D+1)
                    pob_aux(i,j)=trial(1,j-1); % Auxiliar pop is used to avoid changes of pop until the whole next population is created
                end
                pob_aux(i,1)=error_trial;
            else
                for j=1:(D+1)
                    pob_aux(i,j)=population(i,j);
                end
            end
        else         % With thresgolding. The improvement must be bigger than 2%.
            if(error_trial<population(i,1)*1.00) % Thresholding band Thau= 0.02
                for j=2:(D+1)
                    pob_aux(i,j)=trial(1,j-1);
                end
                pob_aux(i,1)=error_trial;
            else
                for j=1:(D+1) 
                    pob_aux(i,j)=population(i,j); 
                end
            end
        end
    end
    
    % Population for the next generation
    population=pob_aux;
    
    % Discarding: The worst elements are replaced by other ones closer to
    % the best candidates.
    if version_de~=2
        pob_orden=sortrows(population,1);
%         for i=1:(double(int8(NP/20)))
%             disc=random('unid',NP/2);
%             while disc==0
%                 disc=random('unid',NP/2);
%             end
%             pob_orden(NP+1-i,:)=pob_orden(disc,:);
%         end
        population=pob_orden;
    end 
    
    % We register the best and the worst candidates and the sum of errors.   
    error_aux=population(1,1);
    for j=1:(D+1) 
        bestmem(1,j)=population(1,j);
    end
    error_ave=error_aux/(NUM_MEASUREMENTS); % Average error per measurement, in cells
    if ((abs(error_aux-error))<1)  % Convergence criterium
        count_b=count_b+1;
    else
        count_b=0;
    end
    error=error_aux;
    error_max_aux=max(population(:,1));
    if ((abs(error_max-error_max_aux))<1)   % Convergence criterium
        count_a=count_a+1;
    else
        count_a=0;
    end
    error_max=error_max_aux;
    dif_errores_aux=error_max-error;
    if (abs(dif_errores_aux-dif_errores)<1)   % Convergence criterium
        count_c=count_c+1;
    else
        count_c=0;
    end    
    dif_errores=dif_errores_aux;
    error_global=sum(population(:,1)); 
    
    % When we are close to convergence, the search area is decreased.
    %if error-error_max<1
    %    F=0.05;
    %end
    % When convergence, NP is drastically reduced
    %if error-error_max==0
    %    NP=10;
    %end
    
    if imp_count==200     
        fprintf(1,'\n It: %f Best %f Worst: %f Global: %f Best/Measurements: %f \n Position: x y theta %f %f %f %f \n',count,error,error_max,error_global,error_ave,population(1,2),population(1,3),population(1,4));
        imp_count=0;
        disp('.');
        if (version_fitness==7)
            fprintf(1,'\n Alpha: %f \n',population(1,5));
            disp('.');
        end
        
%         % To display the map and the population set every x iterations.
%         figure(3)
%         imagesc(map','CDataMapping','scaled')
%         %set(gcf,'Color','white');
%         %set(gcf,'BackingStore','off');
%         set(gca,'DataAspectRatio',[1 1 1]);
%         colormap('gray')
%         hold on  
%         plot(population(:,2),population(:,3),'r.','MarkerSize',5);
%         drawnow
        
    end
    imp_count=imp_count+1;    
    
    count=count+1;
end

end


